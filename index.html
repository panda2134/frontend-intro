<!DOCTYPE html>
<html>
  <head>
    <!-- This is normalize.css, used to reset browser-specific styles. -->
    <link rel="stylesheet" href="style/normalize.css">
    <!-- Fonts -->
    <link rel="stylesheet" href="fonts/fonts.css">
    <!-- Main css for this site -->
    <link rel="stylesheet" href="style/main.css">
    <!-- CSS For Highlight.js -->
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.7.2/build/styles/atom-one-dark.min.css">
    <!-- CSS For KaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.2/dist/katex.min.css" integrity="sha384-Cqd8ihRLum0CCg8rz0hYKPoLZ3uw+gES2rXQXycqnL5pgVQIflxAUDS7ZSjITLb5" crossorigin="anonymous">
    <!-- FavIcon -->
    <link rel="shortcut icon" href="favicon.png">
    <!-- Responsive -->
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!-- UTF8 Document -->
    <meta charset="UTF8">
    <title>Frontend Intro</title>
  </head>
  <body>
    <header>
      <h1>Frontend Intro</h1>
    </header>
    <main>
    <section>
      <h2>HTML5 Tags</h2>
      <p>
        Every single beginner loves copy-pasting HTML code from the web. I don't think that's wrong, actually.
        However, one should pay more attention to "where the code comes from".
      </p>
      <p>
        Ask yourself several questions next time before pressing <kbd>Ctrl</kbd> + <kbd>C</kbd> and <kbd>Ctrl</kbd> + <kbd>V</kbd> 's:
        <ol>
          <li>Is the code reviewed (if not recommended) by coding gurus?</li>
          <li>Does the code conform with the official documentation (usually in English)?</li>
          <li>When was the code written? Frontend technologies evolves at lightning speed, and the code you found can be outdated.</li>
          <li>does it contain <em>depreciated</em> usage of APIs / HTML tags? (e.g. <code>&lt;marquee&gt;</code>, <code>&lt;center&gt;</code>, ...)</li>
        </ol>
      </p>
      <p>
        Personally speaking, I'm strongly against copying HTML code from some public blog site (especially Wordpress and CSDN).
        That's because experienced frontend engineers tend to run their own blog sites.
        <a href="https://stackoverflow.com">StackOverflow</a> is a good place for green hands, since answers there are selected and edited by pros.
      </p>
      <p>
        For details about HTML5 tags, do not hesitate to refer to <a href="https://developer.mozilla.org/">Mozilla Developer Network</a>.
        Articles there are eagerly translated into dozens of languages (including Chinese) by volunteers, so language won't be a problem.
      </p>
      <h3>stop using div tags everywhere</h3>
      <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div">MDN Docs</a> describe div as a generic container for flow content.
      In the years before HTML5, it had been used as a container for literally anything. However, this is not a good practice because HTML5 introduced content sectioning tags.
      
      Take a look at <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element#content_sectioning">those elements</a> on MDN.
      
      <section class="practice" id="htmlTagsPractice">
        <h4>Try it yourself!</h4>

        Design a blog landing page. The page contains a header (with a h1 title inside), 2 articles and a footer (containing copyright notices, etc).
        <br>
        Note: articles should be wrapped by a <code>main</code> tag. You only need to code the parts inside <code>body</code> tag.

        <textarea class="target"></textarea>
        <button>Check your answer</button>
        <span class="hint"></span>
      </section>
    </section>

    <section>
      <h2>Devtools</h2>
      In this section, I assume that you're using Google Chrome or Mozilla Firefox.
      The new Microsoft Edge also works in most cases, since it's a chromium-based browser.
      <h3>How to open</h3>
      <ul>
        <li>Windows/Linux: <kbd>F12</kbd></li>
        <li>Mac OS: <kbd>⌥</kbd>+<kbd>⌘</kbd>+<kbd>I</kbd></li>
      </ul>
      <section class="practice" id="devTools1Practice">
        <h4>Try it yourself!</h4>

        Use devtools to modify the list below. Replace the second item with "Tacos".

        <div class="target">
          Lunch
          <ul>
            <li>Sandwich</li>
            <li>French fries</li>
            <li>Spaghetti</li>
          </ul>
        </div>

        <button>Check your answer</button>
        <span class="hint"></span>
      </section>
      <p>
        Also, have a try with CSS styles...
        <section class="practice" id="devTools2Practice">
          <h4>Try it yourself!</h4>

          Use devtools to modify the styles of contents below.
          <br>


          <div class="target">
            This is a simple text. <span id="devTools2T1" class="emphasized-text">This sentence should be red.</span>
            <span id="devTools2T2" class="hidden-text">This sentence shouldn't be visible.</span>
          </div>

          <button>Check your answer</button>
          <span class="hint"></span>
        </section>
      </p>
      <h3>Network tab</h3>
      When it comes to frontend, speed is the most important factor. Poorly designed webpages can take a minute to load, leading to awful user experience.
      There're too much to talk about when it comes to page speed optimization - we won't cover it today, because some tricks can be advanced.
      However, you can have a basic idea about such optimization by simply navigating to "network" tab.
      <section class="practice" id="devTools3Practice">
        <h4>Question</h4>
        <p>
          How many font files are loaded by this page? <input type="number" class="target">
        </p>
        <button>Check your answer</button>
        <span class="hint"></span>
      </section>
      <h3>Debugging</h3>
      The debugging tab can help with your debugging process. Have a try with the example below.
      <section class="practice" id="devTools4Practice">
        <h4>Try it yourself!</h4>
        <p>
          The correct answer is "foo". Change the JavaScript code underneath so any non-empty string is a correct answer.
          <input type="text" class="target">
        </p>
        <button>Check your answer</button>
        <span class="hint"></span>
      </section>
      <!-- Show how to use manually -->
    </section>
    <section>
      <h2>JavaScript</h2>
      <p>
        Many find JavaScript to be annoying, but after understanding its basics you may feel like saved.
        If used properly, its dynamic weak typing can actually accelerate your development, despite some drawbacks.
        <h3>Common Pitfalls and Solutions</h3>
        <div class="center">
          <img src="./img/coercion.jpg" alt="JavaScript Coercion Meme" style="width: 80%;">
        </div> 
        <h3>Null and Undefined</h3>
        JavaScript has 2 categories of nullish values. One is <code>null</code> and another is <code>undefined</code>.
        However they are used in different ways. While <code>undefined</code> are usually used as a default value if nothing has been specified
        explicitly, <code>null</code> is used as a default value for objects.
<pre class="shiki lang-js">
> typeof null
'object'
> typeof undefined
'undefined'</pre>
        You should be very careful with arguments of a function: they can be nullish values!
        <p>
          Useful operators when dealing with nullish values.
          Newer versions of JavaScript introduced some operators to simplify the handling of nullish values. The first is optional chaining(<code>?.</code>):
        </p>
<pre class="shiki lang-js">
> function hasDimension(options) { return typeof (options?.dimension) == 'number'; }
> hasDimension(null)
false
> hasDimension({})
false
> hasDimension({ dimension: 4 })
true
</pre>
        Another operator is the nullish coalescing operator(<code>??</code>). This can provide a default value in case of nullish variables:
<pre class="shiki lang-js">
> const options = { distance: 'minkovski' }
> const dim = options.dimension ?? 2 
> dim // Suppose we'd like to provide a default in case of nullish values
2
> options.dimension || 2 // interesting enough, || also works here! However, limits apply.
2
> options.dimension = 0
0
> options.dimension ?? 2 // Output is 0 !!!
0
> options.dimension || 2 // This is WRONG.
2
</pre>
        Before <code>??</code> is a thing, programmers used <code>||</code>.
        Its truthy value is calculated after converting each operand into boolean variables.
        However, its return value is selected from original operands.

        <p>
          Note: not every browser support these operators, but modern ones do.
          Notoriously, Internet Explorer do not support them. (btw who on earth is still using IE?)
        </p>

        <h3>Basic types</h3>
        The types below are the basic types in JavaScript. 
        <ul>
          <li>String</li>
          <li>Boolean</li>
          <li>Number</li>
          <li>BigInt</li>
          <li>Symbol</li>
          <li>Function</li>
          <li>Object</li>
          <li>Null</li>
          <li>Undefined</li>
        </ul>
        Some common mistakes: first, pay attention to comparision and arithmetic operators.
        Quirks are that numbers can be casted into strings, and booleans can be casted into numbers.
<pre class="shiki lang-js">
> 1 == true
true
> 0 == +null // + is a unary operator
true
> 6 == '6'
true
> 1+2+3+4+5+'6'
'156'</pre>
To avoid these behaviors, you should change your <code>&equals;&equals;</code>'s into <code>&equals;&equals;&equals;</code>'s.
<pre class="shiki lang-js">
> 6 == '6'
true
> 6 === '6'
false
</pre>
      </p>
      What's more, avoid using the <code>typeof</code> operator on complex objects, since they'll always return <code>"object"</code>.
<pre class="shiki lang-js">
> typeof (new Array())
'object'
> typeof (new Date())
'object'
> typeof (new Set())
'object'</pre>
      Instead, you should use <code>instanceof</code>:
<pre class="shiki lang-js">
> const array = new Array()
> array instanceof Array
true
> array instanceof Object
true
> array instanceof Date
false</pre>
      <section class="practice" id="jsNullishPractice">
        <h4>Try it yourself!</h4>

        <p>
          The following function calculated the distance to origin of a point \(u \in \R^n\), which is given as an array of numbers
          (if its not an array, or its length is 0, return undefined). 
          The third argument of the function is an object (possibly null!) containing options for the function. If the 3rd argument contains 
          <code>distance: "manhattan"</code> then the Manhattan distance should be calculated. If  
          <code>distance: "minkovski"</code> then the Minkovski distance should be calculated.
          Otherwise(i.e. it does not contain <code>distance</code>, or <code>options == null</code>), the Euclidean distance will be calculated.
        </p>
        <p>
          In the case of Minkovski distance,
          if another property <code>dimension</code> is given, then it will be used as the parameter \( p \) for Minkovski distance;
          otherwise it will fall back to \( p = 2 \), which is just Euclidean distance.
        </p>
        \begin{align}
        \text{Manhattan}(u) &= \sum |u_i|\\
        \text{Minkovski}(u) &= \left(\sum u_i^p\right)^{1/p}
        \end{align}

        several examples here:
<pre class="shiki lang-js">
dist(null) // return undefined
dist([]) // return undefined
dist([3, 4]) // return: 5
dist([3, 4], {}) // return: 5
dist([3, 4], {distance: "manhattan"}) // returns: 7
dist([3, 4], {distance: "minkovski"}) // returns: 5
dist([3, 4], {distance: "minkovski", dimension: 2}) // returns: 5
dist([3, 4], {distance: "minkovski", dimension: 3}) // returns: about 4.49794</pre>
        Code your solution below:
        <div class="code-filling">
<pre class="shiki lang-js">
function dist(vec, options) {
</pre>
        <textarea class="target"></textarea>
<pre class="shiki lang-js">
}
</pre>
        </div>
        <button>Check your answer</button>
        <span class="hint"></span>
      </section>
      The exercise above contains many points covered in this chapter. For your convenience, the answer is listed below.
      <details>
        <summary>A Possible Solution</summary>
<pre class="shiki lang-js">
function dist(vec, options) { // this line has been written for you.
  if (! (vec instanceof Array) || vec.length == 0) {
    return
  }
  const distanceType = options?.distance ?? "euclidean"
  let dimension = options?.dimension ?? 2

  switch (distanceType) {
    case "manhattan":
      return vec.reduce((s, x) => s + Math.abs(x))
    case "euclidean":
      dimension = 2
    case "minkovski":
      return Math.pow(vec.reduce((s, x) => s + Math.pow(x, dimension), 0),
                      1.0 / dimension)
  }
} // this line has been written for you.</pre>
      </details>
      <h3>Object Inheritance</h3>
      <p>
        In JavaScript, object inheritance, which is based on <em>prototype</em> rather than <em>classes</em>,
        is far different from traditional Object-Oriented practices. In fact there's no real "classes" in JavaScript!
        Each object is created with a function (and of course, <code>new</code> operator).
        When a property is not found on an object, a search along the prototype chain is performed. 
        <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">Read more about this on MDN</a>.
      </p>
      <p>
        However, newer JavaScript language specifications have defined the keyword <code>class</code> and <code>extends</code>,
        which can be used to emulate the behavior of inheritance based on classes.
      </p> <!-- Speaker Note: Talk about the prototype chain in Node.js! Compare both ways of inheritance -->
<pre class="shiki lang-js">
class Vec2D {
  constructor (x = 0, y = 0) { // default parameter in case of undefined
    this.x = x; this.y = y;
  }
  length () {
    return Math.sqrt(x * x + y * y)
  }
}

class MyVec2D extends Vec2D {
  clear () {
    this.x = this.y = 0
  }
}</pre>
      <p>
        Another thing which is worth noticing is the <code>this</code> keyword.
        If a method of an object is called (e.g. <code>obj.foo()</code>), <code>this</code> is binded
        to the method itself (i.e. <code>obj</code>) in the function body. However <code>this</code> can also be manually binded.
      </p>
<pre class="shiki lang-js">
const obj = {
  foo: 1
}
function testThis() {
  console.log(this)
}
testThis.apply(obj) // output is { foo: 1 }</pre>
      <p>
        There are actually 2 types of function in JavaScript, that is, "normal" functions and "arrow" functions. Arrow functions can be created like this:
<pre class="shiki lang-js">
const logEvent = (event) => { console.log(event.target) }
// logEvent is an arrow function (pay attention to curly braces)
const xPlus2 = x => x + 2
// xPlus2 receives a number and add 2 to it, then return the added value
// there's no curly braces, hence the value of the expression after => is returned.
</pre>
        Attention: You cannot bind <code>this</code> to an arrow function. They actually do not have their own lexical <code>this</code>.
<pre class="shiki lang-js">
const obj = {
  foo: 1
}
function testThis() {
  const t = (() => {
    console.log(this)
  }).bind({baz: 2}) // this will NOT work
  t()
}
testThis.apply(obj) // output is still { foo: 1 }</pre>
      </p>
      <h3>Syntactic Sugar 🍬</h3>
      Talk is cheap, just look at the code below!
<pre class="shiki lang-js">
/* Object related */
const baz = 'foobar'
const obj = {
  foo () { // no need to write `"foo": function()`
    return 'bar'
  },
  bar: 1, // quotation marks in keys can be omitted in most cases
  baz // equivalent to "baz": baz
}

/* Unpacking */
const { bar } = obj // now bar == 1
const arr = [6, 2, 1]
const [a0, a1] = arr // now a0 == 6, a1 == 2, arr[2] is discarded
const powArgs = [3, 2]
console.log(Math.pow(...powArgs)) // argument unpacking, output is 9
function testFunc(...args) {
  console.log(args.length) // now args is an array containing all arguments.
  // NOTE: use this to replace the use of `arguments`
}
testFunc(3, 4, 5) // output is 3

/* For loops */
for (let index in arr) { // in -> index
  console.log(index)
} // 0 1 2
for (let value of arr) { // in -> index
  console.log(value)
} // 6 2 1
</pre>
      <h3>Hoisting</h3>
      Let's just start with a question:
      <section class="practice" id="jsHoistingPractice">
        <h4>Question</h4>
<pre class="shiki lang-js">
function main() {
  var output = ''
  for (var i = 1; i <= 3; i++) {
    setTimeout(() => {output += String(i)}, 1000)
  }
  setTimeout(() => console.log(output), 1500)
}
main()</pre>
        <p>
          What's the output of the code above? <input type="text" class="target">
        </p>
        <button>Check your answer</button>
        <span class="hint"></span>
      </section>
      Variable declared with the keyword <code>var</code> have 2 types of lexical scopes.
      <ul>
        <li>
          Global Scope(when declared outside of any function):
          the variable then becomes a property of <code>globalThis</code>
          (<code>window</code> in browsers and <code>global</code> in Node.js)
        </li>
        <li>
          Functional Scope(when declared in a function):
          the variable is accessible in the whole function
        </li>
      </ul>
      <p>
        There're no other scopes, and particularly, JavaScript will not create a new lexical scope of <code>var</code> for each pair of curly braces.
      </p>
      <p>
        A mental model of <code>var</code>'s is: 
        all their declarations are moved to the start of function (or start of file)
        before any code is executed.
      </p>
      <p>
        Most of the cases hoisting is not the expected behavior. Switching to let / const:
<pre class="shiki lang-js">
{
  let a = 1
  // console.log(b); // error!
  {
    let b = 2
    console.log(b)
  }
}
//console.log(a) // error!
const c = 4
//c = 5 // error!
const obj = {}
obj.foo = 'bar' // this works because the reference to object is not changed 
</pre>
        They just behave like variables in most languages, and global variabled declared with let / const will not become a property of <code>globalThis</code>. Sweet.
      </p>
      <h3>MapReduce</h3>
      The methods map/forEach/reduce exist on any array instance (again, in modern browsers).
      Use them instead of for loops to simplify your code.
<pre class="shiki lang-js">
const arr = [1, 2, 3, 4]
console.log(arr.map(x => x + 2)) // [3, 4, 5, 6]
console.log(arr.reduce((s, x) => s + x)) // sum is 10
</pre>
      For more <abbr title="Functional Programming">FP</abbr>-style functions, try <a href="https://www.npmjs.com/package/lodash">lodash</a>.

      <h3>Promise and Async functions</h3>
      <p>
        JavaScript code is ran in a single thread, however it is capable of handling a heavy workload.
        The magic behind is "event loop": methods of time-consuming actions, like HTTP Requests,
        accept a callback parameter. Once the action is done, the callback function will be called.
      </p>
      <p>
        However, having too much callback functions is not a good thing. Look at the Node.js code below:
<pre class="shiki lang-js">
const fs = require('fs')
fs.readFile('./a.txt', (dataA) => {
  console.log(dataA.length)
  fs.readFile('./b.txt', (dataB) => {
    console.log(dataB.length)
    fs.readFile('./c.txt', (dataC) =>{
      console.log(dataC.length) // nested functions!
    })
  })
})
</pre>
        <code>Promise</code> provides a way of getting rid of nested functions.
<pre class="shiki lang-js">
const { readFile } = require('fs/promises');

readFile('./a.txt').then(
  (x) => {
    console.log(x.length)
    return readFile('./b.txt')
  }
).then(
  (x) => {
    console.log(x.length)
    return readFile('./c.txt')
  }
).then(
  (x) => {
    console.log(x.length)
  }
)
</pre>
        The code above used the Promise API of file reading in Node.js. A promise can be constructed in the following way:
<pre class="shiki lang-js">
const pr = new Promise((resolve, reject) => {
  // asynchronous operations
  // when ready, call resolve(results)
  // in case of error, call reject(error)
})
pr.then((results1) => {
  // what to do in the next step?
  // if another promise is returned, the next handler will wait for it
}).then((results2) => {
  // do something to the resolved result of the previous promise
})
</pre>
        Promises actually form a chain, just like callback chain, with nested functions
        replaced by <code>resolve</code> and <code>reject</code>.
      </p>

      <section class="practice" id="jsPromisePractice">
        <h4>Try it yourself!</h4>

        <p>
          Promisify the setTimeout API: create a function named <code>timeout</code>,
          which takes an integer (representing timeout in milliseconds) as argument,
          and returns a promise that resolves after the certain timeout.
        </p>

        Code your solution below:
        <div class="code-filling">
          <pre class="shiki lang-js">function timeout(msecs) {</pre>
          <textarea class="target"></textarea>
          <pre class="shiki lang-js">}</pre>
        </div>
        <button>Check your answer</button>
        <span class="hint"></span>
      </section>
      <details>
        <summary>A possible solution</summary>
<pre class="shiki lang-js">
function timeout(msecs) {
  return new Promise(resolve => setTimeout(resolve, msecs))
}</pre>
      </details>
      <h3>Async and Await</h3>
      <p>
      These 2 keywords are just syntactic sugar; a certain async function
<pre class="shiki lang-js">
async foo() {
  // block 1
  let rv = await anotherAsyncFunction();
  // block 2
}
const pr = foo()
</pre>
      can be directly translated into:
<pre class="shiki lang-js">
const pr = new Promise((resolve, reject) => {
  // block 1
  return anotherAsyncFunction().then((rv) => {
    // block 2
  }).catch(e => reject(e))
})</pre>
        This syntactic sugar can turn promise-based code into normal code that runs "sequentially".
      </p>
      <p>
        Let's rewrite the code of reading 3 text files with <code>async</code>'s!
<pre class="shiki lang-js">
const { readFile } = require('fs/promises');

async function main() {
  let x
  x = await readFile('./a.txt')
  console.log(x.length)
  x = await readFile('./b.txt')
  console.log(x.length)
  x = await readFile('./c.txt')
  console.log(x.length)
}

main()
</pre>
        Note: newer versions of V8 Engine support <code>await</code> outside of functions.
        However we'll just stick to using it in <code>async</code> functions.
      </p>
      <!-- How promises work; how to declare async functions -->
      <h3>A Brief Explanation on Package Management</h3>
      <p> <!-- Example: info.tsinghua.edu.cn -->
        There're too much to talk about on this matter: JavaScript had had no "import" before several years ago.
        If your code depend on other libraries, you should add the script tag of the library before the script tag of yours.
        Soon as the number of number of dependencies increase, your script tags become a mess, because they have to be loaded in the correct order.
      </p>
      <p>
        Then tools like RequireJS appeared. It required all scripts following a specific module definition format (AMD/UMD/CommonJS),
        and the tool handles all the importing for you. An example of AMD Module looks like this:
<pre class="shiki lang-js">
define(['jquery'], function ($) {
  $(function() {
    // blahblahblah
  }) // run after the page is loaded
})
</pre>
        However this is still annoying: you have to download all dependencies of your code manually from the web,
        and loading too much dependencies is certainly detrimental to the load speed.
      </p>
      <p>
        People then turned to Node.js, since it has an package management system called <code>npm</code>.
        They coded build tools for frontend code, which are called bundlers. The popular bundlers are: Webpack, Rollup(used by vue-cli), Browserify, to name but a few.
        Bundlers came out and dominated frontend development till now. They build the production-ready code from your original codebase,
        help with CommonJS Style <code>require</code> statements, and "polyfill" your code when needed.
        As a result, you're able to use <code>require</code> in frontend code just as in Node.js, and you can use the latest syntax of JavaScript
        without breaking backward compatibility.
      </p>
      <p>
        To understand the configuration of bundlers and CLI build programs (like vue-cli), you should have some knowledge about Node.js.
        It's not hard to learn since the language is the same as that in browsers, with some API changes.
        Refer to their document, and you'll learn about <code>packages.json</code>, <code>node_modules</code> and many more.
      </p>
      <p>
        The ES Modules are introduced by ECMAScript 6 in 2015.
        They provided support for modules in the language itself, rather than an addon or a build tool.
        Most bundlers also support ES Module Syntax (just like you've probably seen in Vue/React projects).
        However, the syntax used in bundlers (path or package in node_modules) is slightly different to the language specification.
        If you want to use imports directly in browsers, you should use a relative or absolute path to the module,
        because there's no such thing as node_modules in this context.
      </p>
      <p>
        Note: do not try to use import directly on CommonJS modules in the browser. If you're using a bundler, then everything's fine
        since the bundler will generate some code to help with the interoperability.
        However, the native <code>import</code> statement is incompatible with CommonJS modules (because you don't have <code>require</code> in a browser).
        Use <a href="https://skypack.dev">Skypack</a> to help you translate CommonJS modules to ES modules.
        This service allows you to import any package on <a href="https://npmjs.com">NPM Registry</a> into your code directly,
        since it does the transpilation under the hood.
      </p>
      <p>
        Fact: The successor of Node.js, <a href="https://deno.land">Deno</a>, abandoned the design of node_modules
        and switched to importing from URLs with ES6 <code>import</code>.
      </p>
      <section class="practice" id="jsImportPractice">
        <h4>Try it yourself!</h4>

        <p>
          Use ES6 syntax to import 2 modules: one at <code>https://cdn.skypack.dev/canvas-confetti</code>,
          another at <code>https://cdn.skypack.dev/parse-color</code>.
          Then inspect the second URL in a new tab manually to see how skypack transpiled the original code and removed calls to <code>require</code>.
        </p>

        Code your solution below:
        <div class="code-filling">
          <textarea class="target"></textarea>
<pre class="shiki lang-js">
console.log(parseColor('#ffa500'))
confetti()</pre>
        </div>
        <button>Check your answer</button>
        <span class="hint"></span>
      </section>
      <h3>Useful APIs</h3>
      Since the time of this workshop is limited, we'll only have a look at <code>Element.querySelector</code> and <code>fetch</code>.
      Again, refer to MDN when you're puzzled by API-related problems.

<pre class="shiki lang-js">
document.querySelector('pre.shiki') // select all &lt;pre&gt; tags with class shiki

fetch('https://jsonplaceholder.typicode.com/posts')
  .then(x => x.json()).then(x => console.log(x.length)) // perform a GET request to the server
fetch('https://jsonplaceholder.typicode.com/posts', { // perform a POST request to the server
  method: 'POST',
  body: JSON.stringify({
    title: 'foo',
    body: 'bar',
    userId: 1,
  }),
  headers: {
    'Content-type': 'application/json',
  },
})
.then(x => x.json())
.then(x => console.log(x))
</pre>
    </section>
    <section>
      <h2>Styling</h2>
      <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps">A Good Tutorial</a>
      <h3>Box Model</h3>
      Open the Devtools to have a look: where's margin / padding / border?
<pre class="shiki lang-css">
* {
  box-sizing: border-box;
}</pre>
      <h3>Block vs Inline</h3>
      There're generally 2 basic types of <code>display</code> in CSS.
      Block elements take all the width of its parent element, and have properties like margin / padding.
      For inline ones <code>margin-top/margin-bottom</code> simply don't work, and they do not expand horizontally like block elements.
      <h3>BEM Naming Convention</h3>
      Most of the CSS Classes are named like
      <pre class="shiki lang-css">.block__element--modifier</pre>
      where block is the parent container, element is the class name for target, and modifier indicates its state.
      <h3>How to vertically center an element?</h3>
      Use the following class on its parent element:
<pre class="shiki lang-css">
.vert-center {
  display: grid;
  align-items: center;
}
</pre>
      An example is given here:
      <iframe height="265" style="width: 100%;" scrolling="no" title="Center" src="https://codepen.io/panda2134/embed/preview/NWdXjeW?height=265&theme-id=light&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
        See the Pen <a href='https://codepen.io/panda2134/pen/NWdXjeW'>Center</a> by panda2134
        (<a href='https://codepen.io/panda2134'>@panda2134</a>) on <a href='https://codepen.io'>CodePen</a>.
      </iframe>

      <p>
        Here CSS Grids are used. <a href="https://css-tricks.com/snippets/css/complete-guide-grid/">CSS Tricks</a> have a complete guide on this.
        You may be interested in <code>display: flex</code>, which is also new in CSS3.
      </p>
      <h3>Style a button</h3>
      We will cover some basic usage of CSS by styling a toggle button.
      <iframe height="265" style="width: 100%;" scrolling="no" title="Button" src="https://codepen.io/panda2134/embed/preview/mdVbzdp?height=265&theme-id=light&default-tab=css,result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">
        See the Pen <a href='https://codepen.io/panda2134/pen/mdVbzdp'>Button</a> by panda2134
        (<a href='https://codepen.io/panda2134'>@panda2134</a>) on <a href='https://codepen.io'>CodePen</a>.
      </iframe>
      <h3>Responsive Web Design and CSS Media Queries</h3>
      To start with, use the following code in your HTML Header:
<pre class="shiki lang-html"><!-- Responsive -->
<meta name="viewport" content="width=device-width,initial-scale=1.0"></pre>
      And then apply different style to different screen sizes:
<pre class="shiki lang-css">
/* Part of CSS Code for this tutorial */
body {
  margin: 20px;
  background-color: #eee;
  font-family: 'Montserrat';
}

@media only screen and (min-width: 850px) {
  body {
    margin-left: 20vw;
    margin-right: 20vw;
  }
}</pre>
      Open this page on your phone, and find out the differences in styling.
      <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Media_Queries/Using_media_queries">Tutorial</a>
    </section>
    <section>
      <h2>HTTP Basics</h2>
      The basic methods, along with their usage in RESTful APIs, are listed below.
      <ul>
        <li>GET: Accepts no body, but search parameters. Only used to retrieve information / get a list of resources.</li>
        <li>POST: Accepts a body, and use the data in body to create new resources on the server.</li>
        <li>PUT: Accepts a body, and use the body to <em>replace</em> a resource on the server.</li>
        <li>PATCH: Accepts a body, and use the body to partially <em>edit</em> a resource on the server.</li>
        <li>DELETE: remove a resource on the server.</li>
        <li>OPTIONS: Preflight requests. Used in <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">CORS</a>.</li>
      </ul>
      Example of <a href="https://jsonplaceholder.typicode.com/posts">JSONPlaceholder</a>.
      <h3>Alternatives to RESTful API</h3>
      GraphQL is a good alternative to RESTful API, since you can get loads of resources in a single request.
      On the other hand, RESTful APIs sometimes send too much requests, making your webpage laggy.
    </section>
    </main>
    <script src="./js/main.mjs" type="module"></script>
  </body>
</html>
